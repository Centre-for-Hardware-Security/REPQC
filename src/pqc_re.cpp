#include <iostream> 
#include <fstream>
#include <string>
#include <map>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <limits>

using namespace std;

void parseZscore(string input);
void parseGrouping(string input, int min_group_size);
void parseDepends(string input);

void printGroups();
void printShrinkGroups(float tolerance);
void printGroupHits();
void findStuff(int candidates);
void eliminateGroupsByRegisterPath(int candidates);
void eliminateGroupsByLowNumber();
void eliminateMembersWithoutHits();
void findWinnerGroup();

struct reg {
	int id;
	float score;
	int hits;
};

struct group {
	int id;
	vector<string> members;
	vector<string> deleted_members;
	float avg_score;
	int dominant_frequency;
	float dominant_score;
	int uniques;
	int non_uniques;
	float score;
};

map<string, reg> myregs;
vector<string> myregs_zordered;
vector<group> mygroups;
map<string, vector<string>> mydepends; // this is so ugly! I should hash...

int main(int argc, char** argv) { 
	if (argc != 6) {
		cout << "wrong number of parameters" << std::endl;
		cout << "the correct usage is " << argv[0] << "file.zscore file.grouping file.depends min_group_size n_candidates" << std::endl;
		cout << "Example: " << argv[0] << " ../results/input.zscore ../results/input.grouping ../results/input.depends 64 300" << std::endl;
		return 0;
	}

	string zscore_file = argv[1];
	string grouping_file = argv[2];
	string depends_file = argv[3];
	int min_group_size = atoi(argv[4]);
	float tolerance = 0.0; // kept here as a reminder that some old code expects this as input
	int candidates = atoi(argv[5]);
	
	parseZscore(zscore_file);
	parseGrouping(grouping_file, min_group_size);
	parseDepends(depends_file);

	// this is strategy 1, it works if the groups can be divided very close to the word size of 64bits
	//printShrinkGroups(tolerance);
	//findStuff(candidates);
	//printGroupHits();

	// this is strategy 2, it works by eliminating groups
	printGroups();
	eliminateGroupsByRegisterPath(candidates);
	eliminateGroupsByLowNumber();
	eliminateMembersWithoutHits();
	findWinnerGroup();

	return 0; 
}

void parseZscore(string input) {
	std::ifstream file(input);
	if (!file) {
		std::cout << "error opening file" << input << std::endl;
		return;
	}
	else {
		cout << "reading " << input << " ..." << endl;
	}

	string part1, part2, part3;

	while(file) {
		file >> part1;
		file >> part2;
		file >> part3;

		if (part2 == "Z-score") {
			// this is the first line, the header, we will ignore it
			file >> part1;
			continue;
		}
		else {
			reg myreg;

			myreg.id = stoi(part1);
			myreg.score = stof(part2);
			myreg.hits = 0;
			myregs[part3] = myreg;

			myregs_zordered.push_back(part3); // to keep they ordered by z score!
		}
	}
	cout << "done parsing scores for a total of " << myregs.size() << " regs" << endl;
}

void parseGrouping(string input, int min_group_size) {
	std::ifstream file(input);
	if (!file) {
		std::cout << "error opening file" << input << std::endl;
		return;
	}
	else {
		cout << "reading " << input << " ..." << endl;
	}

	int count = 0;
	string word;
	group temp;

	temp.avg_score = 0.0;
	temp.dominant_frequency = 0;
	temp.dominant_score = 0.0;
	temp.uniques = 0;
	temp.non_uniques = 0;

	while(getline(file,word)) {
		if (word == "") { // this is an empty line, marks the end of a group
			if (temp.members.size() >= min_group_size) {
				temp.id = count;
				mygroups.push_back(temp);
			}
			temp.members.clear();
			count++;
		} else {
			temp.members.push_back(word);
		}
	}
	cout << "done parsing groups, considered " << mygroups.size() << " groups out of " << count << endl;
}

void parseDepends(string input) {
	std::ifstream file(input);
	if (!file) {
		std::cout << "error opening file" << input << std::endl;
		return;
	}
	else {
		cout << "reading " << input << " ..." << endl;
	}

	string part1, part2, part3;
	int count = 0;

	while(file) {
		file >> part1; // source
		file >> part2; // arrow symbol
		file >> part3; // destination
		count++;

		if (mydepends.find(part3) == mydepends.end()) {// meaning the map does not contain an entry for this reg yet
			vector<string> temp;
			temp.push_back(part1);
			mydepends[part3] = temp;
		}
		else {
			mydepends[part3].push_back(part1);
		}
	}
	cout << "done parsing depends file for a total of " << count << " dependencies" << endl;
}


void printGroups() {
	ofstream logfile;
	logfile.open ("../results/groups.log");
	logfile << "generated by pqc_re. src code available from https://github.com/Centre-for-Hardware-Security/re_pqc \n";
	logfile << "the structure is as follows:" << endl;
	logfile << "groups are separated by -------- group ID -------- lines" << endl;
	logfile << "members of a group are listed by: name z-score" << endl; 

	for (auto& it1 : mygroups) {
		cout << "------------- group " << it1.id << " -------------" << endl;
		logfile << "------------- group " << it1.id << " -------------" << endl;

		vector<float> dist;

		for (auto& it2 : it1.members) {
			logfile << it2 << " " << myregs[it2].score << endl;
			dist.push_back(myregs[it2].score);
		}
		// I am looking for groups of AT LEAST 64 members, no worries with div by 0
		double sum = std::accumulate(std::begin(dist), std::end(dist), 0.0);
		double m =  sum / dist.size();
		
		double accum = 0.0;
		std::for_each (std::begin(dist), std::end(dist), [&](const double d) {
		    accum += (d - m) * (d - m);
		});
		
		double stdev = sqrt(accum / (dist.size()-1));
	
		cout << "STATS: group " << it1.id << " has " << it1.members.size() << " members" << endl;
		logfile << "STATS: group " << it1.id << " has " << it1.members.size() << " members" << endl;
		cout << "STATS: group " << it1.id << " has an avg score of " << m << " with a std_dev of " << stdev << endl;
		logfile << "STATS: group " << it1.id << " has an avg score of " << m << " with a std_dev of " << stdev << endl;

	}
	logfile.close();
}

void eliminateMembersWithoutHits() {
	for (auto& it1 : mygroups) {
		cout << "------------- group " << it1.id << " -------------" << endl;

		cout << "STATS: group " << it1.id << " had " << it1.members.size() << " members" << endl;
	
		for (auto it2 = it1.members.begin(); it2 != it1.members.end(); ) {
			if (myregs[*it2].hits == 0) { // was never hit!
				it2 = it1.members.erase(it2);
			}
			else {
				it2++;
			}
		} 

		cout << "STATS: group " << it1.id << " has " << it1.members.size() << " members" << endl;
	}
}

void printShrinkGroups(float tolerance) {
	ofstream logfile;
	logfile.open ("../results/groups.log");
	logfile << "generated by pqc_re. src code available from https://github.com/Centre-for-Hardware-Security/re_pqc \n";
	logfile << "the structure is as follows:" << endl;
	logfile << "groups are separated by -------- group ID -------- lines" << endl;
	logfile << "members of a group are listed by name z-score frequency" << endl; 

	for (auto& it1 : mygroups) {
		cout << "------------- group " << it1.id << " -------------" << endl;
		logfile << "------------- group " << it1.id << " -------------" << endl;
		
		map<float, int> table;

		for (auto& it2 : it1.members) {
			logfile << it2 << " " << myregs[it2].score << endl;
		
			float reference = myregs[it2].score;
			
			if (table.find(reference) == table.end()) {// meaning the table does not contain an occurence for reference
				table[reference] = 0;
			
				for (auto& it3 : it1.members) { // 
					float candidate = myregs[it3].score;
					if (candidate == reference) {
						table[reference]++;
					}
				}
			}
		}

		int freq = 0;
		float score = 0.0;
		for(const auto& elem : table) {
			logfile << "table: " << elem.first << " " << elem.second << "\n"; // reg name | z-score | frequency of the z-score
			if (elem.second > freq) { 
				freq = elem.second;
				score = elem.first;
			}
		}

		it1.dominant_frequency = freq;
		it1.dominant_score = score;		

		cout << "STATS: group " << it1.id << " has " << it1.members.size() << " members" << endl;
		logfile << "STATS: group " << it1.id << " has " << it1.members.size() << " members" << endl;
		logfile << "STATS: group " << it1.id << " has a dominant score of " << it1.dominant_score << " with a frequency of " << it1.dominant_frequency << endl;

		if (tolerance == 0.0) {
			continue;
		}
		else {
			for (auto it2 = it1.members.begin(); it2 != it1.members.end(); ) {
				float upper_limit = it1.dominant_score * (1 + tolerance);
				float lower_limit = it1.dominant_score * (1 - tolerance);
				float score = myregs[*it2].score;

				if ((score >= upper_limit) || (score <= lower_limit)) { // group member must be deleted
					it1.deleted_members.push_back(*it2);
					it2 = it1.members.erase(it2);
				}
				else {
					it2++;
				}
			}
			logfile << "STATS: group " << it1.id << " has " << it1.deleted_members.size() << " deleted members" << endl;
			logfile << "STATS: group " << it1.id << " has " << it1.members.size() << " current members" << endl;		
		}		

	}
	logfile.close();
}

void findStuff(int candidates) {
	int regcount = 0;

	for (auto& it1 : myregs_zordered) {
		vector <string> deps;
		deps = mydepends[it1];
		
		//cout << "considering " << it1 << " as target. it has " << deps.size() << " dependencies" << endl;

		for (auto& it2 : mygroups) {
			int hits = 0;
			int misses = 0;
			for (auto& it3 : it2.members) {
				// check if member it3 of group it2 has a path to reg it1
				//cout << "checking if " << it3 << " has a path to " << it1 << endl;
				
				if ( find(deps.begin(), deps.end(), it3) != deps.end() ) {
					hits++;
					myregs[it3].hits++; // is this enough? maybe i need to iterate over all
				}
				else {
					misses++;
				}
			}

			//cout << "group " << it2.id << " finished with " << hits << " hits and " << misses << " misses" << endl;
			if (hits==1) {
				it2.uniques++;
			}
			else {
				it2.non_uniques++;
			}
		}
		regcount++;

		if (regcount == candidates) {break;}; // reached the number of candidates regs to be considered
	}
}

void eliminateGroupsByRegisterPath(int candidates) {
	int regcount = 0;

	for (auto& it1 : myregs_zordered) {
		vector<int> to_delete;
		vector <string> deps;
		deps = mydepends[it1];  
		
		cout << "considering " << it1 << " as target, it has " << deps.size() << " dependencies" << endl;

		if (deps.size() < 64) {continue;}; // this idea has some merit, I should think some more

		for (auto it2 = mygroups.begin(); it2 != mygroups.end(); it2++) {
			int hits = 0;
			int misses = 0;
			for (auto& it3 : it2->members ) {
				// check if member it3 of group it2 has a path to reg it1
				//cout << "checking if " << it3 << " has a path to " << it1 << endl;

				if (it1 == it3) { // checking if there is a path from reg_x to reg_x is useless
					hits = 0;
					break;
				}

				if ( find(deps.begin(), deps.end(), it3) != deps.end() ) {
					hits++;
					myregs[it3].hits++;
				}
				else {
					misses++;
				}
			}

			cout << "group " << it2->id << " finished with " << hits << " hits and " << misses << " misses" << endl;
			if (hits==0) {
				cout << "group " << it2->id << " is marked for deletion " << endl;
				to_delete.push_back(it2->id);			
			}
			else { // probably not needed anymore
				if (hits==1) {
					it2->uniques++;
				}
				else {
					it2->non_uniques++;
				}
			}			
		}
		regcount++;

		if ( (mygroups.size() - to_delete.size()) >= 1) { // meaning I can delete and there will still be something left
			for (auto it3 : to_delete) {
				for (auto it2 = mygroups.begin(); it2 != mygroups.end(); ) {
					if (it2->id == it3) {
						it2 = mygroups.erase(it2);
					}
					else { it2++;}
				}
			}
		}
		else {
			cout << "ALGORITHM ended, will stop trying new regs!" << endl;
			return;
		}

		if (regcount == candidates) {break;}; // reached the number of candidates regs to be considered
	}
}

void eliminateGroupsByLowNumber() {
	int highest_score = 0;
	cout << "considering LOW!REG!COUNT!" << endl;

	for (auto it1 = mygroups.begin(); it1 != mygroups.end(); ) {
		int hits = 0;
		for (auto& it2 : it1->members) {
			if (myregs[it2].hits != 0) { 
				hits++;
			}
		}

		if (hits < 64) {
			cout << "group " << it1->id << " will be eliminated" << endl;
			it1 = mygroups.erase(it1);
		}
		else {
			it1++;
		}
	}	
}


void printGroupHits() {
	ofstream logfile;
	logfile.open ("../results/result.txt");

	int highest_score = 0;

	for (auto& it1 : mygroups) {
		int hits = 0;
		for (auto& it2 : it1.members) {
			if (myregs[it2].hits != 0) { 
				hits++;
				cout << "group " << it1.id << ", reg " << it2 << ", score " << myregs[it2].score << ", hits " << myregs[it2].hits << endl;
			}
		}

		float score = (hits*it1.uniques) - (hits*it1.non_uniques);
		it1.score = score;

		if (score > highest_score) {
			highest_score = score;
		}
		
		cout << "group " << it1.id << " has a total of " << hits << "/" << it1.members.size() << " hit regs/total regs and ";
		cout << it1.uniques << "/" << it1.non_uniques << " uniques/non_uniques and its score is: " << score << endl;
	}
	return;
	for (auto& it1 : mygroups) {
		if (it1.score==highest_score) {
			cout << "the winner with " << highest_score << " score is group " << it1.id << endl;
			logfile << "the winner with " << highest_score << " score is group " << it1.id << endl;
			cout << "its \"hit\" members are: " << endl;
			logfile << "its \"hit\" members are: " << endl;
			for (auto& it2 : it1.members) {
				if (myregs[it2].hits != 0) { 
					cout << it2 << " " << myregs[it2].score << endl;
					logfile << it2 << " " << myregs[it2].score << endl;
				}
			}			

			cout << "its \"non-hit\" members are: " << endl;
			for (auto& it2 : it1.members) {
				if (myregs[it2].hits == 0) { 
					logfile << it2 << " " << myregs[it2].score << " " << myregs[it2].hits << endl;
				}
			}
		}
	}

	logfile.close();
}


void findWinnerGroup() {
	ofstream logfile;
	logfile.open ("../results/result.txt");

	float lowest_sum = std::numeric_limits<float>::max(); // highest possible float
	float lowest_g = std::numeric_limits<float>::max(); // highest group score
	int g_id;

	for (auto& it1 : mygroups) {
		vector<float> scores;
		float sum = 0.0;

		for (auto& it2 : it1.members) {
			scores.push_back(myregs[it2].score);
		}

		sort(scores.begin(), scores.end());
	
		int count = 0;
		for (auto& score : scores) {    
			sum = sum + score;
			count++;
			if (count == 64) break;
		}

		if (sum < lowest_g) { 
			lowest_g = sum;
			g_id = it1.id;
		}
	
		cout << "group " << it1.id << " has a score of " << sum << endl;
	}

	cout << "overall lowest score is from group " << g_id << endl;

	for (auto& it1 : mygroups) {
		if (it1.id == g_id) {
			multimap<float, string> scores;
	
			for (auto& it2 : it1.members) {
				scores.insert(pair<float,string>(myregs[it2].score, it2));
				//scores[myregs[it2].score] = it2;
			}
	
			int count = 0;
			for (auto& score : scores) {    
				cout << count << ": " << score.first << " " << score.second << endl;
				count++;
				if (count == 64) break;
			}
		}
	
	}

	logfile.close();
}




