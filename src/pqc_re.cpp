#include <iostream> 
#include <fstream>
#include <string>
#include <map>
#include <unordered_map>
#include <vector>
#include <algorithm>

using namespace std;

void parseZscore(string input);
void parseGrouping(string input, int min_group_size);
void printShrinkGroups(int tolerance);
void parseDepends(string input);
void printGroupHits();
void findStuff();

struct reg {
	int id;
	float score;
	bool hit;
};

struct group {
	vector<string> members;
	vector<string> deleted_members;
	float avg_score;
	int dominant_frequency;
	float dominant_score;
	int uniques;
	int non_uniques;
	float score;
};

map<string, reg> myregs;
vector<string> myregs_zordered;
vector<group> mygroups;
map<string, vector<string>> mydepends; // this is so ugly! I should hash...

int main(int argc, char** argv) { 
	if (argc != 6) {
		cout << "wrong number of parameters" << std::endl;
		cout << "the correct usage is " << argv[0] << "file.zscore file.grouping file.depends min_group_size tolerance" << std::endl;
		cout << "Example: " << argv[0] << " ../results/input.zscore ../results/input.grouping ../results/input.depends 64 5" << std::endl;
		return 0;
	}

	string zscore_file = argv[1];
	string grouping_file = argv[2];
	string depends_file = argv[3];
	int min_group_size = atoi(argv[4]);
	int tolerance = atoi(argv[5]);
	
	parseZscore(zscore_file);
	parseGrouping(grouping_file, min_group_size);
	parseDepends(depends_file);
	printShrinkGroups(tolerance);

	findStuff();

	printGroupHits();

	return 0; 
}

void parseZscore(string input) {
	std::ifstream file(input);
	if (!file) {
		std::cout << "error opening file" << input << std::endl;
		return;
	}
	else {
		cout << "reading " << input << " ..." << endl;
	}

	string part1, part2, part3;

	while(file) {
		file >> part1;
		file >> part2;
		file >> part3;

		if (part2 == "Z-score") {
			// this is the first line, the header, we will ignore it
			file >> part1;
			continue;
		}
		else {
			reg myreg;

			myreg.id = stoi(part1);
			myreg.score = stof(part2);
			myreg.hit = false;
			myregs[part3] = myreg;

			myregs_zordered.push_back(part3); // to keep they ordered by z score!
		}
	}
	cout << "done parsing scores for a total of " << myregs.size() << " regs" << endl;
}

void parseGrouping(string input, int min_group_size) {
	std::ifstream file(input);
	if (!file) {
		std::cout << "error opening file" << input << std::endl;
		return;
	}
	else {
		cout << "reading " << input << " ..." << endl;
	}

	int count = 0;
	string word;
	group temp;

	temp.avg_score = 0.0;
	temp.dominant_frequency = 0;
	temp.dominant_score = 0.0;
	temp.uniques = 0;
	temp.non_uniques = 0;

	while(getline(file,word)) {
		if (word == "") { // this is an empty line, marks the end of a group
			if (temp.members.size() >= min_group_size) {
				mygroups.push_back(temp);
			}
			temp.members.clear();
			count++;
		} else {
			temp.members.push_back(word);
		}
	}
	cout << "done parsing groups, considered " << mygroups.size() << " groups out of " << count << endl;
}

void parseDepends(string input) {
	std::ifstream file(input);
	if (!file) {
		std::cout << "error opening file" << input << std::endl;
		return;
	}
	else {
		cout << "reading " << input << " ..." << endl;
	}

	string part1, part2, part3;
	int count = 0;

	while(file) {
		file >> part1; // source
		file >> part2; // arrow symbol
		file >> part3; // destination
		count++;

		if (mydepends.find(part3) == mydepends.end()) {// meaning the map does not contain an entry for this reg yet
			vector<string> temp;
			temp.push_back(part1);
			mydepends[part3] = temp;
		}
		else {
			mydepends[part3].push_back(part1);
		}
	}
	cout << "done parsing depends file for a total of " << count << " dependencies" << endl;
}


void printShrinkGroups(int tolerance) {
	ofstream logfile;
	logfile.open ("groups.log");
	logfile << "generated by pqc_re. src code available from https://github.com/Centre-for-Hardware-Security/re_pqc \n";
	logfile << "the structure is as follows:" << endl;
	logfile << "groups are separated by -------- group ID -------- lines" << endl;
	logfile << "members of a group are listed by name z-score frequency" << endl; 

	int count = 0;
	for (auto& it1 : mygroups) {
		cout << "------------- group " << count << " -------------" << endl;
		logfile << "------------- group " << count << " -------------" << endl;
		
		map<float, int> table;

		for (auto& it2 : it1.members) {
			logfile << it2 << " " << myregs[it2].score << endl;
		
			float reference = myregs[it2].score;
			
			if (table.find(reference) == table.end()) {// meaning the table does not contain an occurence for reference
				table[reference] = 0;
			
				for (auto& it3 : it1.members) { // 
					float candidate = myregs[it3].score;
					if (candidate == reference) {
						table[reference]++;
					}
				}
			}
		}

		int freq = 0;
		float score = 0.0;
		for(const auto& elem : table) {
			logfile << "table: " << elem.first << " " << elem.second << "\n"; // reg name | z-score | frequency of the z-score
			if (elem.second > freq) { 
				freq = elem.second;
				score = elem.first;
			}
		}

		it1.dominant_frequency = freq;
		it1.dominant_score = score;		

		cout << "STATS: group " << count << " has " << it1.members.size() << " members" << endl;
		logfile << "STATS: group " << count << " has " << it1.members.size() << " members" << endl;
		logfile << "STATS: group " << count << " has a dominant score of " << it1.dominant_score << " with a frequency of " << it1.dominant_frequency << endl;
		count++;

		if (tolerance == 0) {
			continue;
		}
		else {
			for (auto it2 = it1.members.begin(); it2 != it1.members.end(); ) {
				float upper_limit = it1.dominant_score * (100 + tolerance)/100;
				float lower_limit = it1.dominant_score * (100 - tolerance)/100;
				float score = myregs[*it2].score;

				if ((score >= upper_limit) || (score <= lower_limit)) { // group member must be deleted
					it1.deleted_members.push_back(*it2);
					it2 = it1.members.erase(it2);
				}
				else {
					it2++;
				}
			}
			logfile << "STATS: group " << count << " has " << it1.deleted_members.size() << " deleted members" << endl;
			logfile << "STATS: group " << count << " has " << it1.members.size() << " current members" << endl;
						
		}		
	}
	logfile.close();
}

void findStuff() {
	int regcount = 0;
	int groupcount = 0;

	for (auto& it1 : myregs_zordered) {
		vector <string> deps;
		deps = mydepends[it1];
		groupcount = 0;
		
		//cout << "considering " << it1 << " as target. it has " << deps.size() << " dependencies" << endl;

		for (auto& it2 : mygroups) {
			int hits = 0;
			int misses = 0;
			for (auto& it3 : it2.members) {
				// check if member it3 of group it2 has a path to reg it1
				//cout << "checking if " << it3 << " has a path to " << it1 << endl;
				
				if ( find(deps.begin(), deps.end(), it3) != deps.end() ) {
					hits++;
					myregs[it3].hit = true;
				}
				else {
					misses++;
				}
			}

			//cout << "group " << groupcount << " finished with " << hits << " hits and " << misses << " misses" << endl;
			groupcount++;
			if (hits==1) {
				it2.uniques++;
			}
			else {
				it2.non_uniques++;
			}
		}
		regcount++;

		if (regcount >= 40) {break;};
	}
}

void printGroupHits() {
	int count = 0;
	int highest_score = 0;

	for (auto& it1 : mygroups) {
		int hits = 0;
		for (auto& it2 : it1.members) {
			if (myregs[it2].hit == true) { 
				hits++;
				//cout << it2 << endl;
			}
		}

		float score = (hits*it1.uniques) - (hits*it1.non_uniques);
		it1.score = score;

		if (score > highest_score) {
			highest_score = score;
		}
		
		cout << "group " << count << " has a total of " << hits << "/" << it1.members.size() << " hit regs/total regs and ";
		cout << it1.uniques << "/" << it1.non_uniques << " uniques/non_uniques" << "and its score is: " << score << endl;
		count++;
	}

	count = 0;
	for (auto& it1 : mygroups) {
		if (it1.score==highest_score) {
			cout << "the winner with " << highest_score << " score is group " << count << endl;
			cout << "its \"hit\" members are: " << endl;
			for (auto& it2 : it1.members) {
				if (myregs[it2].hit == true) { 
					cout << it2 << " " << myregs[it2].score << endl;
				}
			}
		}
	
		count++;
	}

}




